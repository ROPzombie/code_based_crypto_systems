\documentclass[11pt%
%,draft%
,aspectratio=169%
]{beamer}
%
\usepackage{fontspec}
\defaultfontfeatures{Ligatures=TeX}
\setsansfont{Liberation Sans}
\usepackage{polyglossia}
\setdefaultlanguage{german}
%
\include{fu_beamer_template}
%
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
%
\usepackage{graphicx}

\author{Lea Muth \and Benjamin Tröster}
\title[Code-basierte Kryptografie]{Einführung Code-basierte Kryptografie}
\subtitle{Code-basiertes Kryptosystem -- McEliece}
%\pgfdeclareimage{titlegraphic}{pictures/mceliece.png}
%\titlegraphic{\pgfuseimage{titlegraphic}}
\date{\today}
%\subject{}
%
% FU settings
\institute[FU Berlin]{Freie Universität Berlin}
%\pgfdeclareimage[height=0.9cm]{logo}{../res/dwarf_logo}
%\logo{\pgfuseimage{logo}}
%
\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}{Fahrplan}
\tableofcontents[hideothersubsections]
\end{frame}

\section*{Zusammmenfassung}
\begin{frame}{Zusammmenfassung}
	\begin{itemize}
		\item McEliece asymmetrisches Public-Key-Kryptosystem -- 1978 nach Robert McEliece \cite{McEliece1978public}
		\item Grundlegende Idee: Führe absichtliche Fehler in die Chiffre ein 
		\item Verwenden eines allgemeinen fehlerkorrigierende Codes
		\begin{itemize}
		    \item Dekodierung i.A. $NP$-Hart \cite[S. 479]{Schneier2007Applied}, \cite[S. 353ff]{Stinson2018Cryptography}
		    \item Unterklasse an linearen Codes auch in $P$ lösbar $\rightarrow$ Goppa-Codes
		\end{itemize}
	\end{itemize}
\end{frame}

\section{Generelle Idee}

\begin{frame}{Generelle Idee}
	\begin{itemize}
		\item 
		Das asymmetrische McEliece Pulic-Key-Verfahren baut auf allgemein binär linearen fehlerkorrigierenden Codes auf und fügt absichtlich Fehler in eine Chiffre ein, um deren Kryptoanalyse zu erschweren.
		\\Die grundlegende Idee basiert auf der Verwendung eines allgemeinen fehlerkorrigierenden Codes, da die Dekodierung solcher Codes ein NP schweres Problem ist. Für bestimmte Code-Untergruppen wie z.B. Goppa-Codes ist hierbei eine Lösung in poynomialer Zert möglich.
		
	\end{itemize}
\end{frame}

\section{Grundlagen}

\begin{frame}{Fahrplan Grundlagen}
\tableofcontents[currentsection,currentsubsection]
\end{frame}

\subsection{Hamming Distanz}
\begin{frame}{Hamming Distanz}
	\begin{itemize}
		\item Die Hamming Distanz $d$ ist ein Maß für die Unterschiedlichkeit von Zeichenketten und ist eine Metrik auf dem Coderaum.
		\\Es sei $\Sigma$ ein diskretes Alphabet und $c_1=(c_{1_1},\ldots,c_{1_n})$ ,$c_2=(c_{2_1},\ldots,c_{2_n})$ Codeworte mit je $n$ Buchstaben aus $\Sigma^n$, von denen die Teilmenge  $C\subseteq\Sigma^n$ die gültigen Codeworte darstellt. 
		\\Die Hamming Distanz zwischen $c_1$ und $c_2$ ist definiert als \[\Delta(c_1,c_2):=|\{i \in \{1,\ldots,n\}| c_{1_i}\neq c_{2_i} \}|\]
		\item Beispiel:
		\item Für mehr als zwei Worte versteht man das Minimum aller Abstände zwischen verschiedenen Wörtern innerhalb des Codes als deren Hamming Distanz.
		\[d=\Delta(C):= \min_{\forall i,j \in \{1,\ldots,n\}|i\neq j}\Delta(c_i,c_j)\]
		\item Beispiel:
	
		
	\end{itemize}
\end{frame}

\subsection{Linear-Codes}
\begin{frame}{Linear-Codes}
	\begin{itemize}
		\item Ein Blockcode $C\subseteq\Sigma^n$ heißt linearer Code, wenn die Summer zweier Codewörter wieder ein Codewort ist, d.h. wenn gilt:
			\[\forall c_1,c_2 \in C \colon c1\oplus c2 \in C \]
			$C$ bildet damit einen Vektorraum und ist Unterraum des Vektorraumes $\Sigma^n$.
			\item Beispiel:
			\item Es sei die k die Dimension des Vektorraumes in dem sich der lineare Code $C$ befindet, so nennt man $C$ einen $[n,k]$-Code. Bei gegebener Hamming Distanz $d$ wird dieser auch $[n,k,d]$-Code genannt.
	
	\end{itemize}
\end{frame}

\subsection{Goppa-Codes}
\begin{frame}{(binary) Goppa-Codes}
	\begin{itemize}
		\item 
	\end{itemize}
\end{frame}

\section{McEliece -- Code-basierte Kryptografie}

\begin{frame}{Fahrplan Code-basierte Kryptografie}
\tableofcontents[currentsection,currentsubsection]
\end{frame}

\begin{frame}{Code-basierte Kryptografie}
	\begin{itemize}
		\item Einleitender Foobar Kram aus: \cite{Stinson2018Cryptography}
	\end{itemize}
\end{frame}

\subsection{McEliece-Kryptosystem}

\begin{frame}{Grundlegende Idee McEliece Kryptosystem}
	\begin{itemize}
		\item Transformiere Klartext $m$ mithilfe einer Generator-Matrix in Goppa-Code
		\item Multiplikation mit randomisierten Matrizen führt zu allgemeinem linearen Code
		\begin{itemize}
		    \item Konfusion \& Diffusion
		\end{itemize}
		\item Retransformation ohne Matrizen in Goppa-Code ist problemtisch: $NP$-Hart
        \item Öffentlicher Schlüssel: $M_G$
        \begin{itemize}
            \item Anzahl der maximal eingebauten Fehler in der Chiffre $c$
            \item D.h. Anzahl der Bits, die invertiert werden sollen
        \end{itemize}
	    \item Privater Schlüssel: Umwandlung des allgemeinen, linearen Codes in Goppa-Code
	    \begin{itemize}
	        \item Für performante Retransformation
	        \item Und Fehlerkorrektur
	    \end{itemize}
	\end{itemize}
\end{frame}

\subsection{Parameter Definitionen}
\begin{frame}{Parameter Definitionen}
    \begin{itemize}
        \item Systemparameter $m$ gibt die Blockgröße an
        \item $C$ sei ein binärer $(n,k)$ Goppa-Code mit $t$ effizient korrigierbaren Fehlern
        \item $t$ gibt die maximale Anz. eff. korrigierbarer Fehler durch Goppa-Code $C$
        \item Daraus ergeben sich:
        \begin{itemize}
            \item Blocklänge Chiffretext: $n = 2^m$
            \item Nachricht Blocklänge $k = n - m \cdot t$
            \item Minimale \emph{Hamming-Distance} $d$ des Codes $C$: $d = 2 \cdot t + 1$
        \end{itemize}
    \end{itemize}   
\end{frame}

\subsection{McEliece-Algorithmus}
\begin{frame}{McEliece-Algorithmus}
    \begin{itemize}
        \item Das \emph{McEliece}-Kryptosystem $\Pi := (Gen, Enc, Dec)$
        \item Wobei:
        \begin{itemize}
            \item $Gen$ Schlüsselerzeugung
            \item $Enc$ Verschlüsselung
            \item $Dec$ Entschlüsselung
        \end{itemize}
        \item Korrekheit: Es muss gelten
        $$
            m = Dec_{priv}(c) = Dec_{priv} (Enc_{pub}(m))
        $$
    \end{itemize}
\end{frame}

\subsection{Schlüsselerzeugung $Gen$}
\begin{frame}{Schlüsselerzeugung $Gen$}
\begin{itemize}
    \item Erzeuge Generator-Matrix $G$ $\dim{G} = k \times n$ für Goppa-Code $C$
    \begin{itemize}
        \item Matrix aus der binärer Klartext mit Länge $k$ die Chiffre der Länge $n$ berechnet werden kann
    \end{itemize}
    \item Erzeuge zufällige, binäre, nicht singuläre\footnote{M.a.W. $S$ ist regulär, $\det S \neq 0$; wichtig für Invertierbarkeit} \emph{Scramble-Matrix} $S := k \times k$
    \begin{itemize}
        \item $S$ muss in $\mathbb{Z}_2$ invertierbar sein
    \end{itemize}
    \item Permutationsmatrix $P$ der Größe $n \times n$
    \begin{itemize}
        \item Binärmatrix, mit in jede Zeile genau ein 1 Element enthalten ist
    \end{itemize}
    \item Berechne: $\hat{G} = SGP$ mit $k \times n$
    \item Schlüssel: $K := (GmS,P,\hat{G},t)$
    \begin{itemize}
        \item Öffentlicher Schlüssel: $K_{pub}:= (\hat{G}, t)$
        \item Privater Schlüssel: $K_{priv} := (G,S,P)$
    \end{itemize}
\end{itemize}
\end{frame}

\subsection{Verschlüsselung $Enc$}
\begin{frame}{Verschlüsselung $Enc$}
    \begin{itemize}
        \item Nachricht in Blöcke, sodass $m \in \mathbb{Z}_2^k$
        \item $Enc_{pub}(m,z) = c = m\hat{G} + z$
        \item Sei $z \in \mathbb{Z}_2^n$ ein belieber Vektor der Länge $n$, mit maximaler Gewichtung $t$
        \item Gewichtung $t$: maximale Anzahl Einsen in $z$
        \item Fehlervektor erlaubt es Chiffre an maximal $t$ Stellen zu invertieren
    \end{itemize}
\end{frame}
    
\subsection{Entschlüsselung $Dec$}
\begin{frame}{Entschlüsselung $Dec$}
    \begin{itemize}
        \item Berechne $\hat{c} = cP^{-1}$
        \item Anwenden der $decode(c)$ des Goppa-Codes auf $\hat{c}$, sodass $\hat{m}$ gefunden werden kann
        \item Hamming-Distanz: $d_H(\hat{m}G, \hat{c}) \leq t$
        \item Eigentliche Entschlüsselung: $m = \hat{m}S^{-1}$
        \item Kompakt: $dec_{priv}(c) = decode(cP^{-1}) \cdot S^{-1}$
    \end{itemize}    
\end{frame}

\subsection{Beispiel McElicece-Kryptosystem}
\begin{frame}{Beispiel McElicece-Kryptosystem}
    \begin{itemize}
        \item Kryptosystem $(n,k,d)$ mit Systmeparameter: $n=7, k=4, d=3$
        \begin{itemize}
            \item 4 Bit Klartext auf $7$ Bit Chiffretext
            \item Hamming-Distanz $d=3$
            \item Somit lassen sich $t = \frac{d-1}{2} = 1$ Bitfehler korrigieren
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Beispiel McElicece-Kryptosystem, cont'}
    \begin{itemize}
        \item Schlüsselerzeugung $Gen$: Generator-Matrix erzeugt Hamming-Code statt Goppa-Code
        \item $G=\begin{pmatrix} 1 & 0 & 0 & 0 & 1 & 1 & 0 \\ 0 & 1 & 0 & 0 & 1 & 0 & 1 \\ 0 & 0 & 1 & 0 & 0 & 1 & 1 \\ 0 & 0 & 0 & 1 & 1 & 1 & 1 
        \end{pmatrix}$\\
        Da $d=3$ unterscheidet sich jede Zeile in mindestens drei Werten
        \item Zufällige Matrizen $S$ und $P$
        $S=\begin{pmatrix} 1 & 1 & 0 & 1 \\ 1 & 0 & 0 & 1 \\ 0 & 1 & 1 & 1 \\ 1 & 1 & 0 & 0 \end{pmatrix} \qquad
        P=\begin{pmatrix} 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 & 0 \end{pmatrix}$
    \end{itemize}
\end{frame}

\begin{frame}{Beispiel McElicece-Kryptosystem, cont'}
Berechnung des öffentlichen Schlüssels $\hat{G} = S \cdot G \cdot P$:
$$
    \hat{G}=\begin{pmatrix} 1 & 1 & 0 & 1 \\ 1 & 0 & 0 & 1 \\ 0 & 1 & 1 & 1 \\ 1 & 1 & 0 & 0 \end{pmatrix} \cdot \begin{pmatrix} 1 & 0 & 0 & 0 & 1 & 1 & 0 \\ 0 & 1 & 0 & 0 & 1 & 0 & 1 \\ 0 & 0 & 1 & 0 & 0 & 1 & 1 \\ 0 & 0 & 0 & 1 & 1 & 1 & 1 \end{pmatrix} \cdot \begin{pmatrix} 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 & 0 \end{pmatrix}=
$$
$$
    =\begin{pmatrix} 1 & 1 & 0 & 1 & 1 & 0 & 0 \\ 1 & 0 & 0 & 1 & 0 & 0 & 1 \\ 0 & 1 & 1 & 1 & 0 & 0 & 1 \\ 1 & 1 & 0 & 0 & 0 & 1 & 1 \end{pmatrix} \cdot \begin{pmatrix} 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 & 0 \end{pmatrix}= \begin{pmatrix} 1 & 1 & 1 & 1 & 0 & 0 & 0 \\ 1 & 1 & 0 & 0 & 1 & 0 & 0 \\ 1 & 0 & 0 & 1 & 1 & 0 & 1 \\ 0 & 1 & 0 & 1 & 1 & 1 & 0 \end{pmatrix}
$$
\end{frame}

\begin{frame}{Beispiel McElicece-Kryptosystem, cont'}
Der öffentlichen Schlüssels $K_{pub} = (\hat{G},t)$:
$$
    K_{pub} = (\hat{G},t) =\left(\begin{pmatrix} 1 & 1 & 1 & 1 & 0 & 0 & 0 \\ 1 & 1 & 0 & 0 & 1 & 0 & 0 \\ 1 & 0 & 0 & 1 & 1 & 0 & 1 \\ 0 & 1 & 0 & 1 & 1 & 1 & 0 \end{pmatrix},1\right)
$$
\end{frame}

\begin{frame}{Beispiel McElicece-Kryptosystem, cont'}
Nachricht $m = \begin{pmatrix} 1 1 0 1 \end{pmatrix}$, Fehlervektor $z$ mit maximalem Gewicht $t = 1$ und Länge $n = 7$: \\
Wähle $z =  \begin{pmatrix} 0 0 0 0 1 0 0 \end{pmatrix}$ 
$$
    Enc_{pub}(m,z) = c = m\hat{G} + z
$$
\begin{align*}
    m &= \begin{pmatrix} 1 & 1 & 0 & 1 \end{pmatrix} \cdot \begin{pmatrix} 1 & 1 & 1 & 1 & 0 & 0 & 0 \\ 1 & 1 & 0 & 0 & 1 & 0 & 0 \\ 1 & 0 & 0 & 1 & 1 & 0 & 1 \\ 0 & 1 & 0 & 1 & 1 & 1 & 0 \end{pmatrix} + \begin{pmatrix} 0 & 0 & 0 & 0 & 1 & 0 & 0 \end{pmatrix}\\
    &= \begin{pmatrix} 0 & 1 & 1 & 0 & 0 & 1 & 0 \end{pmatrix} + \begin{pmatrix} 0 & 0 & 0 & 0 & 1 & 0 & 0 \end{pmatrix}\\
    &= \begin{pmatrix} 0 & 1 & 1 & 0 & 1 & 1 & 0 \end{pmatrix}=c    
\end{align*}
\end{frame}

\begin{frame}{Beispiel McElicece-Kryptosystem, cont'}
Entschlüsselung der Chiffre:\\
Invertierung der Permuation $\hat{c} = cP^{-1}$
\begin{align*}
       c &= \begin{pmatrix} 0 & 1 & 1 & 0 & 1 & 1 & 0 \end{pmatrix} \cdot \begin{pmatrix} 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 & 0 \end{pmatrix}\\
       &= \begin{pmatrix} 1 & 0 & 0 & 0 & 1 & 1 & 1 \end{pmatrix}
\end{align*}
\end{frame}

\begin{frame}{Beispiel McElicece-Kryptosystem, cont'}
\begin{itemize}
    \item Dekodierung des Hamming-Codes:
    \item Berehcne Hamming-Distanz $d$ der Generator-Matrix $G$: $\begin{pmatrix} 1 & 3 & 3 & 2 \end{pmatrix}$
    \item Somit ist $\hat{m} = \begin{pmatrix} 1 & 0 & 0 & 0\end{pmatrix}$
    \item Berechne Klartext $m$
\end{itemize}

\begin{align*}
        m &= \hat{m}S^{-1}=\\
        &= \begin{pmatrix} 1 & 0 & 0 & 0 \end{pmatrix} \cdot \begin{pmatrix} 1 & 1 & 0 & 1 \\ 1 & 1 & 0 & 0 \\ 0 & 1 & 1 & 1 \\ 1 & 0 & 0 & 1 \end{pmatrix}\\
        &= \begin{pmatrix} 1 & 1 & 0 & 1 \end{pmatrix}
\end{align*}
\end{frame}

\subsection{Vor- \& Nachteile}
\begin{frame}{Vor- \& Nachteile}
    \begin{itemize}
        \item The good news: Es McEliece gab keine erfolgreichen Angriffe gegen das McEliece-Verfahren 
        \item Jedoch:
        \begin{itemize}
            \item Bruce Schneier: McEliece-Kryptosystem etwa 2 bis 3 mal langsamer als RSA \cite[S. 479ff]{Schneier2007Applied}
            \item Extrem große öffentliche Schlüssel: $\hat{G}$ ist Matrix $k \times n$
            \item Bei Parameter $(1024,524,101)$ ist $k \cdot n = 1024 \cdot 524 = 536576$ Bit also etwa 67$kBytes$
            \item Chiffretext ist fast doppelt so groß wie Klartext, aus $524 Bit$ klartext werden zu $1024$ Bit Chiffre 
        \end{itemize}
     \end{itemize}
\end{frame}

\section{Quellen}
\appendix
\begin{frame}[allowframebreaks]
  \frametitle<presentation>{Sources}
\bibliographystyle{alpha}
\bibliography{sources}
\end{frame}
\end{document}