\documentclass[11pt%
%,draft%
,aspectratio=169%
]{beamer}
%
\usepackage{fontspec}
\defaultfontfeatures{Ligatures=TeX}
%\setsansfont{Liberation Sans}
\usepackage{polyglossia}
\setdefaultlanguage{german}

%
\include{fu_beamer_template}
%biber stuff
\usepackage[
  backend=biber,
  bibencoding=utf8,
  style=alphabetic,
  %citestyle=authoryear-comp
]{biblatex}
\bibliography{sources.bib}
%
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\usepackage[backend=biber]{biblatex}

%
\usepackage{graphicx}
%tikz stuff
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}

\author{Lea Muth \and Benjamin Tröster}
\title[Code-basierte Kryptografie]{Einführung Code-basierte Kryptografie}
\subtitle{Code-basiertes Kryptosystem -- McEliece}
%\pgfdeclareimage{titlegraphic}{pictures/mceliece.png}
%\titlegraphic{\pgfuseimage{titlegraphic}}
\date{\today}
%\subject{}
%
% FU settings
\institute[FU Berlin]{Freie Universität Berlin}
%\pgfdeclareimage[height=0.9cm]{logo}{../res/dwarf_logo}
%\logo{\pgfuseimage{logo}}
%
\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}{Fahrplan}
\tableofcontents[hideothersubsections]
\end{frame}

\section*{Zusammmenfassung}
\begin{frame}{Zusammmenfassung}
	\begin{itemize}
		\item McEliece asymmetrisches Public-Key-Kryptosystem -- 1978 nach Robert McEliece \cite{McEliece1978public}
		\item Grundlegende Idee: Führe absichtliche Fehler in die Chiffre ein 
		\item Verwenden eines allgemeinen fehlerkorrigierende Codes
		\begin{itemize}
		    \item Dekodierung i.A. $\mathcal{NP}$-Hart \cite[S. 479]{Schneier2007Applied}, \cite[S. 353ff]{Stinson2018Cryptography}
		    \item Unterklasse an linearen Codes auch in $P$ lösbar $\rightarrow$ Goppa-Codes
		\end{itemize}
		\item Angreifer ohne Goppa-Code kann nur in $\mathcal{P}$, also polynomiell viel rechnen
		\begin{itemize}
		    \item Die Entschlüsselung eines zufälligen linearen Codes ist ein $\mathcal{NP}$-Hartes Problem -> \cite{ljubic2004exact}
		    \item Die Generatormatrix eines Goppa-Codes sieht zufällig aus ->  \cite{6553164} 
		\end{itemize}
	\end{itemize}
\end{frame}

\section{Grundlagen}

\begin{frame}{Fahrplan Grundlagen}
\tableofcontents[currentsection,currentsubsection]
\end{frame}
\subsection{Hamming Gewicht und Distanz}
\begin{frame}{Hamming Gewicht}
	\begin{itemize}
		\item Das Hamming Gewicht eines Vektors $x$ der Länge $n$ ist definiert als:
		       \[ weight_{\Delta}(x):= \sum_{i=1}^n weight_{\Delta}(x_i)  \]
		       \\mit\\ $weight_{\Delta}(x_i) = 1: x_i \neq 0$, \\$weight_{\Delta}(x_i) =0 : x_i = 0$ 
     	\item Beispiel:
					$$
					weight_{\Delta}(\underline{1}00\underline{1})  = 2
					$$
	\end{itemize}
\end{frame}



\begin{frame}{Hamming Distanz}
	\begin{itemize}
		\item Sei $\Sigma$ ein diskretes Alphabet und $c_1=(c_{1_1},\ldots,c_{1_n})$ ,$c_2=(c_{2_1},\ldots,c_{2_n})$ Codewörter sodass $c_1, c_2 \in C\subseteq\Sigma^n$, wboei $C$ die Menge der gültigen Codeworte darstellt
		\item Hamming Distanz $d$ zwischen $c_1$ und $c_2$ ist definiert als: 
		\[\Delta(c_1,c_2):=|\{i \in \{1,\ldots,n\}| c_{1_i}\neq c_{2_i} \}
		\]
		\item Beispiel:
			\begin{align*}
		        11011001\oplus 10011101 = 0\underline{1}000\underline{1}00 &\implies \Delta(11011001,10011101) = 2
		    \end{align*}
	\end{itemize}
\end{frame}

\begin{frame}{Hamming Distanz}
	\begin{itemize}
		\item Für mehr als zwei Worte versteht man das Minimum aller Abstände zwischen verschiedenen Wörtern innerhalb des Codes als deren Hamming Distanz.
		\[d=\Delta(C):= \min_{\forall i,j \in \{1,\ldots,n\}|i\neq j}\Delta(c_i,c_j)\]
		\item Beispiel:
		\begin{align*}
		    010\oplus 011 = 00\underline{1} &\implies \Delta(010,011) = 1\\
		    010\oplus 101 = \underline{1}\underline{1}\underline{1} &\implies \Delta(010,101) = 3\\
		    011\oplus 101 = \underline{1}\underline{1}0 &\implies \Delta(011,101) = 2
		\end{align*}
		$$ 
		d=\min\{1,3,2\}=1
		$$
	\end{itemize}
\end{frame}
\subsection{Galoiskörper}
\begin{frame}{Galoiskörper}
	\begin{itemize}
		\item Ein endlicher Körper der abgeschlossen bezüglich '$+$' und '$*$'.\\
		\item Beispiel:\\
		   Die Restklassen modulo 2 bilden den Körper $\mathbb{F}_{2} = GF(2)$. \cite{Kunz1991}\\
		   \begin{itemize}		  
		   	\item Addition: $0+0=0$, $0+1=1$, $1+0=1$, $1+1=0$ \\
		    \item Multiplikation: $0*0 = 0*1 = 1*0 = 0$, $1*1=1$ 	
		   	\end{itemize}
	\end{itemize}
\end{frame}

\subsection{Linear-Codes}
\begin{frame}{Linear-Codes}
	\begin{itemize}
		\item Ein binärer Blockcode $C\subseteq GF(2^n) \subseteq \Sigma^n$ heißt linearer Code, wenn gilt:
			\[\forall c_1,c_2 \in C \colon c1\oplus c2 \in C \]
		\item Bei gegebener Hamming Distanz $d$ wird der Code C auch $(n,k,d)$-Code genannt. 
	\end{itemize}
\end{frame}


\subsection{Goppa-Codes}

\begin{frame}{Goppa-Codes}
	\begin{itemize}
		\item Ein Goppa Polynom $g_i \in GF(p^m)$ wird definiert durch:
			\[ g(x) = g_0+g_1x +\ldots+ g_tx^t = \sum_{i=0}^t g_ix^i \]
		\item Es sei L eine endliche Untergruppe $GF(p^m)$, wobei p eine Primzahl ist.
			\[L =\{\alpha_1,\ldots\alpha_n\}\subseteq GF(p^m) \] mit $g(\alpha_i)\neq 0~ \forall \alpha_i \in L$. 
	\end{itemize}
\end{frame}
\begin{frame}{(binary) Goppa-Codes}
	\begin{itemize}
		\item Ein binärer Goppa-Code $\Gamma(L,g(x))$ ist ein $(n,k,d)$-Code, der durch ein Generatorpolynom $g(x) \in GF(2^n)$ vom Grad $t$ und einer Sequenz $L$, über dem endlichen Körper $GF(2^n)$ definiert ist. 
	\end{itemize}
\end{frame}

\section{McEliece -- Code-basierte Kryptografie}

\begin{frame}{Fahrplan Code-basierte Kryptografie}
\tableofcontents[currentsection,currentsubsection]
\end{frame}


\subsection{McEliece-Kryptosystem}

\begin{frame}{Grundlegende Idee McEliece Kryptosystem}
	\begin{itemize}
		\item Transformiere Klartext $m$ (Message) mithilfe einer Generator-Matrix in allgemeinen Goppa-Code
		\item Multiplikation mit randomisierten Matrizen führt zu allgemeinem linearen Code
		\begin{itemize}
		    \item Gist: Reihe von Matrix-Multiplikationen ist Verschlüsselung
		\end{itemize}
		\item Retransformation ohne Matrizen in Goppa-Code ist problemtisch: $\mathcal{NP}$-Hart \cite{Stinson2018Cryptography}
        \item Öffentlicher Schlüssel:
        \begin{itemize}
            \item Beinhaltet Generator-Matrix zur Umwandlung in allg. linearen Code
            \item Zusätzlich: Anzahl der maximal einbaubaren Fehler in der Chiffre $c$
            \item Fehler sind also die Anzahl der Bits, die invertiert werden sollen
        \end{itemize}
	    \item Privater Schlüssel: Umwandlung des allgemeinen, linearen Codes in Goppa-Code
	    \begin{itemize}
	        \item Für performante Retransformation
	        \item Und Fehlerkorrektur
	    \end{itemize}
	\end{itemize}
\end{frame}
 

\subsection{Parameter Definitionen}
\begin{frame}{Parameter Definitionen}
    \begin{itemize}
        \item Systemparameter $m$ gibt die Blockgröße an, für zu verschlüsselnde Nachricht
        \item $C$ sei ein binärer $(n,k)$ Goppa-Code mit $t$ effizient korrigierbaren Fehlern
        \item $t$ gibt die maximale Anz. eff. korrigierbarer Fehler durch Goppa-Code $C$ \footnote{McEliece fixiert $t=50$, als Maximalwert \cite{McEliece1978public}}
        \item Daraus ergeben sich:
        \begin{itemize}
            \item Blocklänge Chiffretext: $n = 2^m$
            \item Nachricht Blocklänge $k = n - m \cdot t$
            \item Minimale \emph{Hamming-Distance} $d$ des Codes $C$: $d = 2 \cdot t + 1$
        \end{itemize}
    \end{itemize}   
\end{frame}

\subsection{McEliece Algorithmus}
\begin{frame}{McEliece als CPA-Sicheres kryptografisches Shema}
    \begin{itemize}
        \item Das \emph{McEliece}-Kryptosystem $\Pi := (Gen, Enc, Dec)$
        \item Wobei:
        \begin{itemize}
            \item $Gen$ Schlüsselerzeugung
            \item $Enc$ Verschlüsselung
            \item $Dec$ Entschlüsselung
        \end{itemize}
        \item Korrekheit: Es muss gelten
        $$
            m = Dec_{priv}(c) = Dec_{priv} (Enc_{pub}(m))
        $$
    \end{itemize}
\end{frame}

\subsection{Schlüsselerzeugung $Gen$}
\begin{frame}{Schlüsselerzeugung $Gen$}
\begin{itemize}
    \item Erzeuge Generator-Matrix $G^{k \times n}$  für Goppa-Code $C$
    \begin{itemize}
        \item Matrix aus der binärer Klartext mit Länge $k$ die Chiffre der Länge $n$ berechnet werden kann
    \end{itemize}
    \item Erzeuge zufällige, binäre, nicht singuläre\footnote{M.a.W. $S$ ist regulär, $\det S \neq 0$; wichtig für Invertierbarkeit} \emph{Scramble-Matrix} $S^{k \times k}$
    \begin{itemize}
        \item $S$ muss in $\mathbb{Z}_2$ invertierbar sein
    \end{itemize}
    \item Permutationsmatrix $P^{n \times n}$
    \begin{itemize}
        \item Binärmatrix, je Zeile genau ein 1 Element enthalten ist
    \end{itemize}
    \item Berechne: $G'^{k \times n} = S \cdot G \cdot P$
    \item Schlüssel: $K := (G,S,P,G',t)$
    \begin{itemize}
        \item Öffentlicher Schlüssel: $K_{pub}:= (G', t)$
        \item Privater Schlüssel: $K_{priv} := (G,S,P)$
    \end{itemize}
\end{itemize}
\end{frame}

\subsection{Verschlüsselung $Enc$}
\begin{frame}{Verschlüsselung $Enc$}
    \begin{itemize}
        \item Nachricht in Blöcke, sodass $m \in \mathbb{Z}_2^k$
        \item Sei $z \in \mathbb{Z}_2^n$ ein belieber Vektor der Länge $n$, mit maximaler Gewichtung $t$
        \begin{itemize}
            \item Gewichtung $t$: maximale Anzahl Einsen in $z$
            \item Fehlervektor erlaubt es Chiffre an maximal $t$ Stellen zu invertieren
        \end{itemize}   
        \item $Enc_{pub}(m,z) = c = m \cdot G + z$
    \end{itemize}
\end{frame}
    
\subsection{Entschlüsselung $Dec$}
\begin{frame}{Entschlüsselung $Dec$}
    \begin{itemize}
        \item Berechne $c' = cP^{-1}$
        \begin{itemize}
            \item $c' = c \cdot P^{-1} = (mG' + z) \cdot P^{-1} = (mG'\cdot P^{-1} + z\cdot P^{-1}) = m (SGP\cdot P^{-1}) + z\cdot P^{-1}$
        \end{itemize}
        \item Anwenden $decode(c')$ des Goppa-Codes auf $c'$, sodass $m'$ gefunden werden kann
        \begin{itemize}
            \item Rausrechnen des Fehlervektors $z$
            \item D.h. wir erhalten: $m' = m (SGP\cdot P^{-1}) = m\cdot SG$
            \item Hamming-Distanz: $d_H(m'G, c') \leq t$
            \begin{itemize}
                \item Invertiere mit Generatormatrix $G$ 
            \end{itemize}
        \end{itemize}
        \item Multiplikation mit $S^{-1}$: $m = m'S^{-1}$
        \item Kompakt: $dec_{priv}(c) = decode(cP^{-1}) \cdot S^{-1}$

    \end{itemize}    
\end{frame}

\subsection{Beispiel McElicece-Kryptosystem}
\begin{frame}{Beispiel McElicece-Kryptosystem}
    \begin{itemize}
        \item Kryptosystem $(n,k,d)$ mit Systmeparameter: $n=7, k=4, d=3$
        \begin{itemize}
            \item 4 Bit Klartext auf $7$ Bit Chiffretext
            \item Hamming-Distanz $d=3$
            \item Somit lassen sich $t = \frac{d-1}{2} = 1$ Bitfehler korrigieren
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Beispiel McElicece-Kryptosystem, cont'}
    \begin{itemize}
        \item Schlüsselerzeugung $Gen$: Generator-Matrix erzeugt Hamming-Code statt Goppa-Code
        \item $G=\begin{pmatrix} 1 & 0 & 0 & 0 & 1 & 1 & 0 \\ 0 & 1 & 0 & 0 & 1 & 0 & 1 \\ 0 & 0 & 1 & 0 & 0 & 1 & 1 \\ 0 & 0 & 0 & 1 & 1 & 1 & 1 
        \end{pmatrix}$\\
        Da $d=3$ unterscheidet sich jede Zeile in mindestens drei Werten
        \item Zufällige Matrizen $S$ und $P$
        $S=\begin{pmatrix} 1 & 1 & 0 & 1 \\ 1 & 0 & 0 & 1 \\ 0 & 1 & 1 & 1 \\ 1 & 1 & 0 & 0 \end{pmatrix} \qquad
        P=\begin{pmatrix} 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 & 0 \end{pmatrix}$
    \end{itemize}
\end{frame}

\begin{frame}{Beispiel McElicece-Kryptosystem, cont'}
Berechnung des öffentlichen Schlüssels $G' = S \cdot G \cdot P$:
$$
    G'=\begin{pmatrix} 1 & 1 & 0 & 1 \\ 1 & 0 & 0 & 1 \\ 0 & 1 & 1 & 1 \\ 1 & 1 & 0 & 0 \end{pmatrix} \cdot \begin{pmatrix} 1 & 0 & 0 & 0 & 1 & 1 & 0 \\ 0 & 1 & 0 & 0 & 1 & 0 & 1 \\ 0 & 0 & 1 & 0 & 0 & 1 & 1 \\ 0 & 0 & 0 & 1 & 1 & 1 & 1 \end{pmatrix} \cdot \begin{pmatrix} 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 & 0 \end{pmatrix}=
$$
\end{frame}

\begin{frame}{Beispiel McElicece-Kryptosystem, cont'}
Berechnung des öffentlichen Schlüssels $G' = S \cdot G \cdot P$:
$$
    =\begin{pmatrix} 1 & 1 & 0 & 1 & 1 & 0 & 0 \\ 1 & 0 & 0 & 1 & 0 & 0 & 1 \\ 0 & 1 & 1 & 1 & 0 & 0 & 1 \\ 1 & 1 & 0 & 0 & 0 & 1 & 1 \end{pmatrix} \cdot \begin{pmatrix} 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 & 0 \end{pmatrix}= \begin{pmatrix} 1 & 1 & 1 & 1 & 0 & 0 & 0 \\ 1 & 1 & 0 & 0 & 1 & 0 & 0 \\ 1 & 0 & 0 & 1 & 1 & 0 & 1 \\ 0 & 1 & 0 & 1 & 1 & 1 & 0 \end{pmatrix}
$$
\end{frame}

\begin{frame}{Beispiel McElicece-Kryptosystem, cont'}
Der öffentlichen Schlüssels $K_{pub} = (G',t)$:
$$
    K_{pub} = (G',t) =\left(\begin{pmatrix} 1 & 1 & 1 & 1 & 0 & 0 & 0 \\ 1 & 1 & 0 & 0 & 1 & 0 & 0 \\ 1 & 0 & 0 & 1 & 1 & 0 & 1 \\ 0 & 1 & 0 & 1 & 1 & 1 & 0 \end{pmatrix},1\right)
$$
\end{frame}

\begin{frame}{Beispiel McElicece-Kryptosystem, cont'}
Nachricht $m = \begin{pmatrix} 1 1 0 1 \end{pmatrix}$, Fehlervektor $z$ mit maximalem Gewicht $t = 1$ und Länge $n = 7$: \\
Wähle $z =  \begin{pmatrix} 0 0 0 0 1 0 0 \end{pmatrix}$ 
$$
    Enc_{pub}(m,z) = c = m \cdot G' + z
$$
\begin{align*}
    m &= \begin{pmatrix} 1 & 1 & 0 & 1 \end{pmatrix} \cdot \begin{pmatrix} 1 & 1 & 1 & 1 & 0 & 0 & 0 \\ 1 & 1 & 0 & 0 & 1 & 0 & 0 \\ 1 & 0 & 0 & 1 & 1 & 0 & 1 \\ 0 & 1 & 0 & 1 & 1 & 1 & 0 \end{pmatrix} + \begin{pmatrix} 0 & 0 & 0 & 0 & 1 & 0 & 0 \end{pmatrix}\\
    &= \begin{pmatrix} 0 & 1 & 1 & 0 & 0 & 1 & 0 \end{pmatrix} + \begin{pmatrix} 0 & 0 & 0 & 0 & 1 & 0 & 0 \end{pmatrix}\\
    &= \begin{pmatrix} 0 & 1 & 1 & 0 & 1 & 1 & 0 \end{pmatrix}=c    
\end{align*}
\end{frame}

\begin{frame}{Beispiel McElicece-Kryptosystem, cont'}
Entschlüsselung der Chiffre:\\
Invertierung der Permuation $c' = cP^{-1}$
\begin{align*}
       c' &= \begin{pmatrix} 0 & 1 & 1 & 0 & 1 & 1 & 0 \end{pmatrix} \cdot \begin{pmatrix} 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 & 0 \end{pmatrix}\\
       &= \begin{pmatrix} 1 & 0 & 0 & 0 & 1 & 1 & 1 \end{pmatrix}
\end{align*}
\end{frame}

\begin{frame}{Beispiel McElicece-Kryptosystem, cont'}
\begin{itemize}
    \item Dekodierung des Hamming-Codes:
    \item Berehcne Hamming-Distanz $d$ der Generator-Matrix $G$: $\begin{pmatrix} 1 & 3 & 3 & 2 \end{pmatrix}$
    \item Somit ist $m' = \begin{pmatrix} 1 & 0 & 0 & 0\end{pmatrix}$
    \item Berechne Klartext $m$
\end{itemize}

\begin{align*}
        m &= m'S^{-1}=\\
        &= \begin{pmatrix} 1 & 0 & 0 & 0 \end{pmatrix} \cdot \begin{pmatrix} 1 & 1 & 0 & 1 \\ 1 & 1 & 0 & 0 \\ 0 & 1 & 1 & 1 \\ 1 & 0 & 0 & 1 \end{pmatrix}\\
        &= \begin{pmatrix} 1 & 1 & 0 & 1 \end{pmatrix}
\end{align*}
\end{frame}

\subsection{Vor- \& Nachteile}
\begin{frame}{Vor- \& Nachteile}
    \begin{itemize}
        \item The good news: Es gab keine erfolgreichen Angriffe gegen das McEliece-Verfahren
        \item Verhfahren gilt als  \emph{IND-CCA2} \cite{dottling2012cca2} sicher, somit ist es auch \emph{IND-CPA} sicher \cite{nojima2008semantic}
        \item Angriffe McEliece mit originalen Parametern von 1978 in 1400 Tagen (Einzelne Machine) oder in 7 Tagen mithilfe von 200 CPUs \cite{baldi2016enhanced}, \cite{canteaut1998cryptanalysis}
        \item Jedoch:
        \begin{itemize}
            \item Bruce Schneier: McEliece-Kryptosystem etwa 2 bis 3 mal langsamer als RSA \cite[S. 479ff]{Schneier2007Applied}
            \item Extrem große öffentliche Schlüssel: $\hat{G}$ ist Matrix $k \times n$
            \item Bei Parameter $(1024,524,101)$ ist $k \cdot n = 1024 \cdot 524 = 536576$ Bit also etwa 67$kBytes$
            \item Chiffretext ist fast doppelt so groß wie Klartext, aus $524 Bit$ klartext werden zu $1024$ Bit Chiffre 
        \end{itemize}
     \end{itemize}
\end{frame}

\section{Quellen}
\appendix
\begin{frame}[allowframebreaks]
  \frametitle<presentation>{Quellen}
\printbibliography
\end{frame}
\end{document}